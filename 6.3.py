# методы списков
li = [1, 2, 3, 4, 5, 6, 7]
print('li', li)
li.append('blabla')    # добавление в конце списка
print('li', li)
li.insert(3, [11, 22, 33])    # добавление в заднюю позицию (индекс)
print('li', li)
del(li[4])  # удаление элемента по идексу
print('li', li)
li.remove(5)   # удаляет по значению
print('li', li)
print(li.pop(5))   #   выдавливает из списка и возвращает его
print('li', li)



li = [3, 2, 6, 8, 1, 9, 5, 2]
print('li.count(2)', li.count(2))
del(li[3])
li.sort()
print('li', li)
li.sort(reverse=True)   # сортировка в обратном порядке от большего к меньшему
print('li', li)


li = [3, 2, 6, 8, 1, 0, ['a', 'b', 'c'], 9, 5, 2, 2]
print(li)
# обозначим проблему
li2 = li   # скопируем список
li2[4] = 'заменил что то '    #изменил 2й список
print('li2', li2)   # проверил что изменилось
print('li', li)  # а вот и боль
#  здесь отличие
li2 = li.copy()   # решение, создание копии
li2[4] = 'изменил что то снова'
print('li2', li2)  # проверил что изменилось
print('li', li)     #  вот нет боли
print()
print()
# список внутри списка будет скопирован как ссылка и поэтому изменения затрагиают обе копии
li[6][1] = 11111
print('li', li)
print('li2', li2)
 # решение данной проблемы - использование внешнего метода копирования
  # ней проверяется тип данных и если встречается (список внутри списка)  то для него будет создана поолноценная копияя

li = [1,2,3 ['123', '456', '798'], 3]
import copy

li2 = copy.deepcopy(li)
li2[3][0] = 'ababagalamaga'
print('li2', li2)
print('li', li)
